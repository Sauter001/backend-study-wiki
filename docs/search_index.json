[
  {
    "title": "OSI 7 계층",
    "path": "/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/osi%207%EA%B3%84%EC%B8%B5",
    "content": "OSI 7 계층 목차 - 1계층: 물리 계층 (Physical Layer) - 2계층: 데이터 링크 계층 (Data Link Layer) - 3계층: 네트워크 계층 (Network Layer) - 4계층: 전송 계층 (Transport Layer) - 5계층: 세션 계층 (Session Layer) - 6계층: 표현 계층 (Presentation Layer) - 7계층: 응용 계층 (Application Layer) --- 1계층: 물리 계층 (Physical Layer) 전선, 광섬유, 전파 같은 **물리 신호** 자체를 다루는 층. 0과 1을 전기 신호, 빛, 전파로 바꾸는 일꾼이지. 쉽게 말해 “케이블 꽂아야 인터넷 되잖아?” 그거 담당하는 거. --- 2계층: 데이터 링크 계층 (Data Link Layer) **MAC 주소** 같은 걸로 “이 신호가 누구한테 가야 하는가” 정해주는 층. 스위치가 일하는 구역. 네가 PC방에서 옆자리 애 컴퓨터 말고 네 컴퓨터로만 신호가 잘 들어오는 건 얘 덕분임. --- 3계층: 네트워크 계층 (Network Layer) **IP 주소** 들고 길찾기하는 네비게이션. 라우터가 여기서 땀 뻘뻘 흘려. 서울에서 부산까지 우편 보내듯이, “얘한테 가려면 어디로 돌아야 하나?” 계산해주는 놈들. --- 4계층: 전송 계층 (Transport Layer) **TCP/UDP** 같은 프로토콜이 여기 있음. “패킷 잃어버리면 다시 보내라” 같은 신뢰성 보장(TCP)도 하고, “걍 막 던져 빨리빨리”(UDP)도 함. 게임하다 렉 걸리면 이 층에서 사고 친 거다. --- 5계층: 세션 계층 (Session Layer) 서버와 클라 사이에 **대화방**을 열어주는 층. 로그인 유지, 세션 연결, 끊김 관리 같은 거 한다. 일종의 “전화선 연결 유지” 담당. --- 6계층: 표현 계층 (Presentation Layer) 데이터 **번역기**. 암호화/복호화, 압축/해제, 인코딩 변환 같은 거 처리한다. 네가 JPG 열면 알아서 그림 보여주는 거, 사실 이 층이 뒤에서 고생하는 덕분임. --- 7계층: 응용 계층 (Application Layer) 드디어 네가 직접 보는 영역. **HTTP, FTP, SMTP** 같은 프로토콜이 여기 들어감. 브라우저, 메일, 카톡 같은 애플리케이션들이 얘 덕분에 네트워크랑 대화하는 거지. --- 정리하면 이렇게야: - 1\\~3층: **하드웨어랑 네트워크 인프라** (물리 → MAC → IP) - 4층: **신뢰성 확보** (TCP/UDP) - 5\\~7층: **사람이랑 가까운 영역** (세션 → 데이터 표현 → 애플리케이션)"
  },
  {
    "title": "TCP(Transport Control Protocol)",
    "path": "/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/TCP",
    "content": "TCP(Transport Control Protocol) 3-way handshake TCP에서 연결을 시작할 때 하는 과정 1. SYN (synchronize) - 클라이언트 → 서버 - “나 연결하고 싶어! 그리고 내 시퀀스 번호는 X야.” 여기서 시퀀스 번호(sequence number)는 송신자가 데이터를 순서대로 주고받기 위해 찍는 번호표 같은 것. 2. SYN-ACK (synchronize-acknowledge) - 서버 → 클라이언트 > “좋아, 네 요청 받았어. 네 X도 확인했고, 내 시퀀스 번호는 Y야.” - 서버는 클라이언트의 SYN에 대한 ACK(응답 확인)를 보내고, 자기 것도 새로 SYN으로 던진다. 3. ACK (acknowledge) - 클라이언트 → 서버 >“오케이, 네 Y 확인했어. 이제 진짜 데이터 주고받자.” - 클라이언트가 서버의 SYN에 대한 ACK을 보내면서 연결이 확립됨."
  },
  {
    "title": "Race condition",
    "path": "/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/race-condition",
    "content": "Race condition 목차 - 비유 - 발생 이유? - 해결책 - 현실에서 볼 수 있는 레이스 컨디션 --- **Race Condition(경쟁 상태)**란, 둘 이상의 쓰레드나 프로세스가 공유 자원(메모리, 파일, DB 같은 거)에 동시에 접근해서 결과가 실행 순서에 따라 달라지는 문제야. 말 그대로 “누가 먼저 달려서 도착하냐”에 따라 결과가 뒤집히는 거지. 네가 제어 못 하는 CPU 스케줄링이 순서를 결정하니까 재현도 랜덤하게 돼. 비유 네가 저금통(공유 자원)에 돈을 넣는 상황이라 치자. 쓰레드 A: 저금통 열고, 기존 잔액 1000 확인 → 1000 + 500 저장하려고 함. 쓰레드 B: 동시에 저금통 열고, 기존 잔액 1000 확인 → 1000 + 300 저장하려고 함. A가 저장하기 전에 B가 먼저 저장해버리면? 원래 결과: 1800이어야 정상이잖아. 실제 결과: 1300이 될 수도 있음. (A 값 덮어쓰기 때문) 발생 이유? - 동시성(concurrency): 여러 쓰레드가 병렬/병행 실행될 때. - 공유 자원: 혼자만 쓰면 문제없는데 같이 쓰니까 꼬임. - 동기화 부족: 락(lock)도 안 걸고 무지성 접근할 때. 해결책 1. Lock/Mutex(상호 배제): “야, 내가 쓰는 동안 기다려!” 하고 자물쇠 걸기. 2. Semaphore: 제한된 수만 접근 허용. PC방 자리 제한 같은 거. 3. Atomic 연산: CPU 차원에서 “이건 한 방에 끝낸다” 보장. 4. 트랜잭션: DB에서는 BEGIN → COMMIT으로 묶어 안전하게. 현실에서 볼 수 있는 레이스 컨디션 * 로그인할 때 동시에 같은 계정으로 접속하면 세션 꼬임. * 온라인 쇼핑몰에서 동시에 재고 1개 주문하면 두 명이 다 결제되는 버그. * 멀티스레드 서버에서 로그 파일 접근하다가 문자열이 뒤죽박죽 써짐."
  },
  {
    "title": "UDP",
    "path": "/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/%EC%A0%84%EC%86%A1%EA%B3%84%EC%B8%B5/udp",
    "content": "UDP 목차 - 개요 - 간략히 - 헤더 구조 - 대표 활용 사례 --- 개요 UDP (User Datagram Protocol) 은 전송계층(OSI 4계층)의 연결 없음(connectionless), 비신뢰성(unreliable), 순서 보장 없음 프로토콜이다. \"나 연결할게요! 통신 잘돼요?\" 하고 연결을 시작하는 TCP와 달리, 얘는 “데이터에 담아 던지고 끝. 잘 갔는지는 알 바 아님”의 스타일이다. 확인 문자? 재전송? 흐름/혼잡 제어? 그런 것은 없다. 대신 지연이 작고 오버헤드가 적다는 강력한 장점이 있다. 간략히 - 언제 쓰냐: - 실시간이 생명인 것들 — VoIP, 온라인 게임, 스트리밍(RTP), DNS 질의, DHCP, NTP, Syslog, - QUIC(HTTP/3의 바닥) 같은 프로토콜. UDP를 기반으로 혼잡, 흐름 제어 별도 구현함 - 뭘 안 해주냐: - 연결 수립, 재전송, 순서 보장, 흐름/혼잡 제어. 전부 애플리케이션(혹은 상위 프로토콜)이 책임져야 한다. - 왜 좋냐: - 헤더 8바이트 -> 용량 적음 - 빠르고 단순하다. 내가 통신 과정 제어 가능함. 대신 다듬는 건 스스로 잘해야 할 것. 헤더 구조 - **Source/Destination, Port**: 16비트. IANA 기준 Well-known 0–1023, Registered 1024–49151, Dynamic/Ephemeral 49152–65535. - **Length**: UDP 헤더 + 데이터 전체 길이. - **Checksum**: - 16비트 1의 보수 합. - IPv4에선 선택적(0 허용), IPv6에선 필수. 계산 시 IP 의사헤더(출발지/목적지 IP, 프로토콜 번호, UDP 길이)를 포함해 네트워크 중간 변조도 어느 정도 잡아낸다. - checksum이 있다고 해서 **무결성이 보장되는 건 아니다.** 대표 활용 사례 - **DNS(Domain Name System)**: - 왕복 빨라야 하니 UDP(대부분). 크면 TCP로 폴백 - **DHCP(Dynamic Host Configuration Protocol)**: 브로드캐스트로 IP 임대. - **RTP/RTCP**: 실시간 오디오·비디오 스트리밍. - **NTP**: 시간 동기화. - **Syslog/StatsD**: 로깅/메트릭 파이프—유실 감내. - **QUIC**: !quic - UDP 위에 TLS 1.3 + 혼잡제어 + 스트림 멀티플렉싱 얹은 프로토콜. - HTTP/3가 이걸 활용한다."
  }
]
