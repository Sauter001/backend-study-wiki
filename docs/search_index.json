[{"title":"vite로 react 프로젝트 만드는 법","path":"/lsj-note/make-react-with-vite","content":"vite로 react 프로젝트 만드는 법 목차 - 1. React 프로젝트 생성 - 2. 설치 후 디렉토리 이동 - 3. 개발 모드로 실행 --- 1. React 프로젝트 생성 2. 설치 후 디렉토리 이동 3. 개발 모드로 실행 터미널에 뜨는 로컬 주소(http://localhost:5173)로 들어가면 기본 React 화면 보임"},{"title":"Ag grid, React 실습","path":"/lsj-note/react-aggrid-ex","content":"Ag grid, React 실습 목차 - 스테이지 0: 프로젝트 베이스 깔기 - 스테이지 1: “Hello, Grid” - 스테이지 2: 정렬/필터 강화 + 포매터 - 스테이지 3: 편집 가능 셀 + 검증 - 스테이지 4: 커스텀 셀 렌더러(React) - 스테이지 5: 행 선택 + 툴바 액션 - 스테이지 6: 페이징 + 퀵 필터 - 스테이지 7: 비동기 로딩(REST) + 로딩 오버레이 - 스테이지 8: 컬럼/필터 상태 저장(localStorage) - 스테이지 9: CSV 내보내기(커뮤니티) - 스테이지 10: 성능 튜닝(수천\\~수만 행 대응) - 스테이지 11: 테마/스타일 커스텀(Tailwind 곁들임) - 스테이지 12: 퀘스트 - 디버그 팁(삽질 방지) --- 스테이지 0: 프로젝트 베이스 깔기 - React 앱 생성 - 설치: - 스타일(최신 테마 중 하나): --- 스테이지 1: “Hello, Grid” 가장 기초. 열 정의 + 행 데이터 + 기본 옵션. --- 스테이지 2: 정렬/필터 강화 + 포매터 - 숫자 천단위 콤마, 날짜 포맷, 값 합성 등. - 로 헤더 아래 미니 필터 추가. --- 스테이지 3: 편집 가능 셀 + 검증 - 인라인 수정, 간단한 검증으로 실수 차단. - 로 서버 반영 훅. - 적용시 빨간색으로 바뀌게 하려면 **tailwind 설치**하거나 링크된 css에 속성 정의 해줘야 함 --- 스테이지 4: 커스텀 셀 렌더러(React) - 버튼/뱃지/아이콘 같은 건 렌더러로. - “React 컴포넌트” 그대로 써서 UI 깔끔하게 하기. --- 스테이지 5: 행 선택 + 툴바 액션 - 체크박스 선택, 선택 행 일괄 처리. - 상단에 \"선택 삭제/CSV\" 버튼 두고 로 제어. - 은 deprecated -> 대신 사용 --- 스테이지 6: 페이징 + 퀵 필터 - 페이징은 커뮤니티에서 제공. - 상단에 을 두고 로 실시간 검색. 스테이지 7: 비동기 로딩(REST) + 로딩 오버레이 - JSONPlaceholder로 가짜 데이터 받아보기. --- 스테이지 8: 컬럼/필터 상태 저장(localStorage) - 새로고침 누를 때마다 세팅 날려먹는 뇌절 방지. - 초기 에서 한 번 호출, 상단에 “상태 저장/복원/초기화” 버튼 배치. --- 스테이지 9: CSV 내보내기(커뮤니티) - 엑셀(xlsx)은 엔터프라이즈지만, CSV는 커뮤니티로 충분. --- 스테이지 10: 성능 튜닝(수천\\~수만 행 대응) - 그리드는 가상 스크롤로 기본 빡세게 튜닝돼 있지만, 코드가 병목이면 무의미 해짐. - 는 로 보관하고, 불필요한 재생성 금지. - , , 렌더러는 / . - , 등 불필요한 애니메이션 끄기. - 고빈도 업데이트는 트랜잭션 API 사용: - 셀 렌더러에서 무거운 계산은 값 준비 단계( , 사전 계산)로 빼기. --- 스테이지 11: 테마/스타일 커스텀(Tailwind 곁들임) - 컨테이너는 테마 클래스 + 고정 높이 필수(부모 높이 없으면 그리드 안 보여). - CSS 변수로 테마 색 맛만 살짝 바꾸기(프로젝트 CSS): --- 스테이지 12: 퀘스트 1. “사용자 목록” 로드해서 - 이름/이메일/도시 컬럼 구성 - 정렬/필터 활성화 - 퀵 필터 인풋 연결 - 선택 행 삭제 버튼 구현 2. 나이/연봉 컬럼 추가하고 편집 가능 + 검증(음수 금지) 3. \"상태 저장/복원\" 버튼 만들고 localStorage 연동 4. CSV 내보내기 버튼으로 현재 필터 결과만 추출(기본 동작 OK) 5. 2만 행 페이크 데이터 뿌려서 스크롤/검색 성능 측정(렌더러 최소화) --- - 집계/피벗/행 그룹핑, 서버사이드 로우 모델, 엑셀(xlsx) 내보내기, 마스터/디테일… 이런 건 Enterprise 기능 --- 디버그 팁(삽질 방지) - 그리드 안 보이면 99% “부모 높이 없음”이다. 컨테이너 높이 확실히 줘야함. - 컬럼/데이터가 안 뜨면 콘솔에 찍어서 라이프사이클 확인. - 를 렌더마다 새로 만들면 성능이 죽는다. 넣을 것."},{"title":"OSI 7 계층","path":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/osi%207%EA%B3%84%EC%B8%B5","content":"OSI 7 계층 목차 - 1계층: 물리 계층 (Physical Layer) - 2계층: 데이터 링크 계층 (Data Link Layer) - 3계층: 네트워크 계층 (Network Layer) - 4계층: 전송 계층 (Transport Layer) - 5계층: 세션 계층 (Session Layer) - 6계층: 표현 계층 (Presentation Layer) - 7계층: 응용 계층 (Application Layer) --- 1계층: 물리 계층 (Physical Layer) 전선, 광섬유, 전파 같은 **물리 신호** 자체를 다루는 층. 0과 1을 전기 신호, 빛, 전파로 바꾸는 일꾼이지. 쉽게 말해 “케이블 꽂아야 인터넷 되잖아?” 그거 담당하는 거. --- 2계층: 데이터 링크 계층 (Data Link Layer) **MAC 주소** 같은 걸로 “이 신호가 누구한테 가야 하는가” 정해주는 층. 스위치가 일하는 구역. 네가 PC방에서 옆자리 애 컴퓨터 말고 네 컴퓨터로만 신호가 잘 들어오는 건 얘 덕분임. --- 3계층: 네트워크 계층 (Network Layer) **IP 주소** 들고 길찾기하는 네비게이션. 라우터가 여기서 땀 뻘뻘 흘려. 서울에서 부산까지 우편 보내듯이, “얘한테 가려면 어디로 돌아야 하나?” 계산해주는 놈들. --- 4계층: 전송 계층 (Transport Layer) **TCP/UDP** 같은 프로토콜이 여기 있음. “패킷 잃어버리면 다시 보내라” 같은 신뢰성 보장(TCP)도 하고, “걍 막 던져 빨리빨리”(UDP)도 함. 게임하다 렉 걸리면 이 층에서 사고 친 거다. --- 5계층: 세션 계층 (Session Layer) 서버와 클라 사이에 **대화방**을 열어주는 층. 로그인 유지, 세션 연결, 끊김 관리 같은 거 한다. 일종의 “전화선 연결 유지” 담당. --- 6계층: 표현 계층 (Presentation Layer) 데이터 **번역기**. 암호화/복호화, 압축/해제, 인코딩 변환 같은 거 처리한다. 네가 JPG 열면 알아서 그림 보여주는 거, 사실 이 층이 뒤에서 고생하는 덕분임. --- 7계층: 응용 계층 (Application Layer) 드디어 네가 직접 보는 영역. **HTTP, FTP, SMTP** 같은 프로토콜이 여기 들어감. 브라우저, 메일, 카톡 같은 애플리케이션들이 얘 덕분에 네트워크랑 대화하는 거지. --- 정리하면 이렇게야: - 1\\~3층: **하드웨어랑 네트워크 인프라** (물리 → MAC → IP) - 4층: **신뢰성 확보** (TCP/UDP) - 5\\~7층: **사람이랑 가까운 영역** (세션 → 데이터 표현 → 애플리케이션)"},{"title":"Race condition","path":"/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/race-condition","content":"Race condition 목차 - 비유 - 발생 이유? - 해결책 - 현실에서 볼 수 있는 레이스 컨디션 --- **Race Condition(경쟁 상태)**란, 둘 이상의 쓰레드나 프로세스가 공유 자원(메모리, 파일, DB 같은 거)에 동시에 접근해서 결과가 실행 순서에 따라 달라지는 문제야. 말 그대로 “누가 먼저 달려서 도착하냐”에 따라 결과가 뒤집히는 거지. 네가 제어 못 하는 CPU 스케줄링이 순서를 결정하니까 재현도 랜덤하게 돼. 비유 네가 저금통(공유 자원)에 돈을 넣는 상황이라 치자. 쓰레드 A: 저금통 열고, 기존 잔액 1000 확인 → 1000 + 500 저장하려고 함. 쓰레드 B: 동시에 저금통 열고, 기존 잔액 1000 확인 → 1000 + 300 저장하려고 함. A가 저장하기 전에 B가 먼저 저장해버리면? 원래 결과: 1800이어야 정상이잖아. 실제 결과: 1300이 될 수도 있음. (A 값 덮어쓰기 때문) 발생 이유? - 동시성(concurrency): 여러 쓰레드가 병렬/병행 실행될 때. - 공유 자원: 혼자만 쓰면 문제없는데 같이 쓰니까 꼬임. - 동기화 부족: 락(lock)도 안 걸고 무지성 접근할 때. 해결책 1. Lock/Mutex(상호 배제): “야, 내가 쓰는 동안 기다려!” 하고 자물쇠 걸기. 2. Semaphore: 제한된 수만 접근 허용. PC방 자리 제한 같은 거. 3. Atomic 연산: CPU 차원에서 “이건 한 방에 끝낸다” 보장. 4. 트랜잭션: DB에서는 BEGIN → COMMIT으로 묶어 안전하게. 현실에서 볼 수 있는 레이스 컨디션 * 로그인할 때 동시에 같은 계정으로 접속하면 세션 꼬임. * 온라인 쇼핑몰에서 동시에 재고 1개 주문하면 두 명이 다 결제되는 버그. * 멀티스레드 서버에서 로그 파일 접근하다가 문자열이 뒤죽박죽 써짐."},{"title":"Local storage","path":"/%EC%9B%B9/local-storage","content":"Local storage 목차 - 저장 특성 - 코드 예시 - 간단한 TODO 리스트 - 임시 로그인 토큰 - 활용 방법 - 다른 클라이언트 저장소와 비교 - sessionStorage - IndexedDB --- localStorage는 브라우저 안에 있는 작은 개인 창고다. 브라우저가 제공하는 키-값 저장소라서 문자열만 저장할 수 있고, 용량은 대략 5MB 정도이다. 쿠키처럼 서버에 자동으로 전송되지는 않는다. 저장 특성 - 브라우저를 꺼도 데이터가 계속 저장되어 있다. - **브라우저를 바꾸거나 기기를 바꾸면 데이터가 사라진다.**, 왜냐면 그 저장소는 해당 브라우저/도메인에 국한되기 때문이다. 코드 예시 간단한 TODO 리스트 임시 로그인 토큰 활용 방법 - **로그인 상태 유지(가벼운 경우)**: - JWT 토큰 같은 걸 저장해두면 새로고침해도 로그인 상태를 잃지 않는다. - 다만 민감한 건 보안 때문에 localStorage보단 httpOnly, Secure 쿠키를 쓰는 게 낫다. - **사용자 환경 설정**: - 다크모드/라이트모드, 언어, 폰트 크기 같은 개인 설정을 기억시킬 때 유용함. - **클라이언트 캐싱**: 서버에서 불러온 데이터를 한 번 저장해두고 다시 페이지에 들어올 때 빠르게 띄우는 데 쓸 수 있다. - **폼 임시 저장**: - 글 작성하다가 새로고침해도 날아가지 않게 중간 저장소로 쓰기에 좋음. - 임시저장 기능 다른 클라이언트 저장소와 비교 sessionStorage - localStorage랑 API 똑같은데, **브라우저 탭을 닫으면 데이터가 싹 날아간다**. 탭 단위라서 같은 사이트를 두 개 열면 각자 따로 관리된다. - **사용례**: - **일시적인 폼 데이터**: 결제 페이지에서 새로고침해도 입력한 내용 유지 - **다단계 회원가입**: 1단계→2단계 이동할 때 데이터를 잠시 보관 IndexedDB 3. IndexedDB - 로컬 DB. 객체 저장 가능하고, 수백 MB까지도 쓸 수 있다. 구조화된 데이터 저장에 강함. 비동기 API라서 좀 귀찮음. - 사용례: - **오프라인 웹앱**: 구글 드라이브, 노션 같은 애들이 오프라인 모드에서 여기다 파일 저장 - **대용량 캐싱**: 이미지, 동영상, JSON 같은 거 쌓아두기"},{"title":"Node와 Nodemon의 차이","path":"/%EC%9B%B9/node-vs-nodemon","content":"Node와 Nodemon의 차이 ** ** * 그냥 **Node.js 런타임** 실행기야. * 치면 자바스크립트 파일 한 번 실행하고 끝. * 코드 고치면? 다시 껐다 켜야 함. 즉, 수정 → 저장 → 다시 실행 반복. 귀찮음. --- ** ** * 이름부터 노가다 줄여주는 도우미. “node monitor”라는 뜻. * 코드 파일을 감시(watch)하다가 저장하면 자동으로 프로세스를 재시작해줌. * → 코드 바꾸고 저장 → 바로 재실행. 개발 중에 리로드 노가다 줄여줌. --- **비유** * 는 옛날 TV처럼 채널 돌릴 때 매번 손으로 다이얼 돌려야 하는 거. * 은 리모컨 달린 TV. 버튼 하나로 바로 새로고침 되는 것. --- 즉, 둘 다 실행기는 맞는데: * → 기본 런타임, 배포용/실행용 * → 개발 편의성 도구, 코드 감시+자동 재시작"},{"title":"TCP(Transport Control Protocol)","path":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/%EC%A0%84%EC%86%A1%EA%B3%84%EC%B8%B5/TCP","content":"TCP(Transport Control Protocol) 3-way handshake TCP에서 연결을 시작할 때 하는 과정 1. SYN (synchronize) - 클라이언트 → 서버 - “나 연결하고 싶어! 그리고 내 시퀀스 번호는 X야.” 여기서 시퀀스 번호(sequence number)는 송신자가 데이터를 순서대로 주고받기 위해 찍는 번호표 같은 것. 2. SYN-ACK (synchronize-acknowledge) - 서버 → 클라이언트 > “좋아, 네 요청 받았어. 네 X도 확인했고, 내 시퀀스 번호는 Y야.” - 서버는 클라이언트의 SYN에 대한 ACK(응답 확인)를 보내고, 자기 것도 새로 SYN으로 던진다. 3. ACK (acknowledge) - 클라이언트 → 서버 >“오케이, 네 Y 확인했어. 이제 진짜 데이터 주고받자.” - 클라이언트가 서버의 SYN에 대한 ACK을 보내면서 연결이 확립됨."},{"title":"UDP","path":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/%EC%A0%84%EC%86%A1%EA%B3%84%EC%B8%B5/udp","content":"UDP 목차 - 개요 - 간략히 - 헤더 구조 - 대표 활용 사례 --- 개요 UDP (User Datagram Protocol) 은 전송계층(OSI 4계층)의 연결 없음(connectionless), 비신뢰성(unreliable), 순서 보장 없음 프로토콜이다. \"나 연결할게요! 통신 잘돼요?\" 하고 연결을 시작하는 TCP와 달리, 얘는 “데이터에 담아 던지고 끝. 잘 갔는지는 알 바 아님”의 스타일이다. 확인 문자? 재전송? 흐름/혼잡 제어? 그런 것은 없다. 대신 지연이 작고 오버헤드가 적다는 강력한 장점이 있다. 간략히 - 언제 쓰냐: - 실시간이 생명인 것들 — VoIP, 온라인 게임, 스트리밍(RTP), DNS 질의, DHCP, NTP, Syslog, - QUIC(HTTP/3의 바닥) 같은 프로토콜. UDP를 기반으로 혼잡, 흐름 제어 별도 구현함 - 뭘 안 해주냐: - 연결 수립, 재전송, 순서 보장, 흐름/혼잡 제어. 전부 애플리케이션(혹은 상위 프로토콜)이 책임져야 한다. - 왜 좋냐: - 헤더 8바이트 -> 용량 적음 - 빠르고 단순하다. 내가 통신 과정 제어 가능함. 대신 다듬는 건 스스로 잘해야 할 것. 헤더 구조 - **Source/Destination, Port**: 16비트. IANA 기준 Well-known 0–1023, Registered 1024–49151, Dynamic/Ephemeral 49152–65535. - **Length**: UDP 헤더 + 데이터 전체 길이. - **Checksum**: - 16비트 1의 보수 합. - IPv4에선 선택적(0 허용), IPv6에선 필수. 계산 시 IP 의사헤더(출발지/목적지 IP, 프로토콜 번호, UDP 길이)를 포함해 네트워크 중간 변조도 어느 정도 잡아낸다. - checksum이 있다고 해서 **무결성이 보장되는 건 아니다.** 대표 활용 사례 - **DNS(Domain Name System)**: - 왕복 빨라야 하니 UDP(대부분). 크면 TCP로 폴백 - **DHCP(Dynamic Host Configuration Protocol)**: 브로드캐스트로 IP 임대. - **RTP/RTCP**: 실시간 오디오·비디오 스트리밍. - **NTP**: 시간 동기화. - **Syslog/StatsD**: 로깅/메트릭 파이프—유실 감내. - **QUIC**: !quic - UDP 위에 TLS 1.3 + 혼잡제어 + 스트림 멀티플렉싱 얹은 프로토콜. - HTTP/3가 이걸 활용한다."}]