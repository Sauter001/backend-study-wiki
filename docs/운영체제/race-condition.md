<!-- TOC START -->

## 목차

- [Race condition](#race-condition)
  - [비유](#비유)
  - [발생 이유?](#발생-이유)
  - [해결책](#해결책)
  - [현실에서 볼 수 있는 레이스 컨디션](#현실에서-볼-수-있는-레이스-컨디션)

<!-- TOC END -->

# Race condition

**Race Condition(경쟁 상태)**란, 둘 이상의 쓰레드나 프로세스가 공유 자원(메모리, 파일, DB 같은 거)에 동시에 접근해서 결과가 실행 순서에 따라 달라지는 문제야.
말 그대로 “누가 먼저 달려서 도착하냐”에 따라 결과가 뒤집히는 거지. 네가 제어 못 하는 CPU 스케줄링이 순서를 결정하니까 재현도 랜덤하게 돼.

## 비유 

네가 저금통(공유 자원)에 돈을 넣는 상황이라 치자.

쓰레드 A: 저금통 열고, 기존 잔액 1000 확인 → 1000 + 500 저장하려고 함.

쓰레드 B: 동시에 저금통 열고, 기존 잔액 1000 확인 → 1000 + 300 저장하려고 함.

A가 저장하기 전에 B가 먼저 저장해버리면?

원래 결과: 1800이어야 정상이잖아.

실제 결과: 1300이 될 수도 있음. (A 값 덮어쓰기 때문)

## 발생 이유?

- 동시성(concurrency): 여러 쓰레드가 병렬/병행 실행될 때.
- 공유 자원: 혼자만 쓰면 문제없는데 같이 쓰니까 꼬임.
- 동기화 부족: 락(lock)도 안 걸고 무지성 접근할 때.

## 해결책 

1. Lock/Mutex(상호 배제): “야, 내가 쓰는 동안 기다려!” 하고 자물쇠 걸기.
2. Semaphore: 제한된 수만 접근 허용. PC방 자리 제한 같은 거.
3. Atomic 연산: CPU 차원에서 “이건 한 방에 끝낸다” 보장.
4. 트랜잭션: DB에서는 BEGIN → COMMIT으로 묶어 안전하게.

## 현실에서 볼 수 있는 레이스 컨디션

 * 로그인할 때 동시에 같은 계정으로 접속하면 세션 꼬임.
 * 온라인 쇼핑몰에서 동시에 재고 1개 주문하면 두 명이 다 결제되는 버그.
 * 멀티스레드 서버에서 로그 파일 접근하다가 문자열이 뒤죽박죽 써짐.
